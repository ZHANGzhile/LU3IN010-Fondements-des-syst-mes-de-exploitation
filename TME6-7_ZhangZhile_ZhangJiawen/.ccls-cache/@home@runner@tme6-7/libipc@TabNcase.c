/* Diffusion tampon N case */

#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <libipc.h>

/************************************************************/

/* definition des parametres */

#define NE 2    /* Nombre d'emetteurs         */
#define NR 5    /* Nombre de recepteurs       */
#define NMAX 3  /* Taille du tampon           */

/************************************************************/

/* definition des semaphores */

int EMET;
int MUTEX_NB_RECEPT;
int RECEP[NR];
int MUTEX;

/************************************************************/

/* definition de la memoire partagee */

typedef struct {
    int message[NMAX];
    int index_lect[NR];
    int index_ecrit;
    int nb_recepteurs[NMAX];
} SharedMemory;

SharedMemory *sp;

/************************************************************/

/* variables globales */
int emet_pid[NE], recep_pid[NR];

/************************************************************/

/* traitement de Ctrl-C */

void handle_sigint(int sig) {
    int i;
    for (i = 0; i < NE; i++) kill(emet_pid[i], SIGKILL);
    for (i = 0; i < NR; i++) kill(recep_pid[i], SIGKILL);
    det_sem();
    det_shm((char *)sp);
}

/************************************************************/

/* fonction EMETTEUR */

void emetteur() {
    while (1) {
        P(EMET);

        P(MUTEX);
        int index = sp->index_ecrit;
        sp->message[index] = 42; // exemple de message
        sp->index_ecrit = (index + 1) % NMAX;
        for (int i = 0; i < NR; i++) {
            V(RECEP[i]);
        }
        V(MUTEX);
    }
}

/************************************************************/

/* fonction RECEPTEUR */

void recepteur(int id) {
    while (1) {
        P(RECEP[id]);

        P(MUTEX);
        int index = sp->index_lect[id];
        int message = sp->message[index];
        printf("Recepteur %d a recu le message %d\n", id, message);
        sp->index_lect[id] = (index + 1) % NMAX;
        V(MUTEX);
    }
}

/************************************************************/

int main() {
    struct sigaction action;

    setbuf(stdout, NULL);

    /* Creation du segment de memoire partagee */
    sp = (SharedMemory *)init_shm(sizeof(SharedMemory));

    /* creation des semaphores */
    EMET = creer_sem(1);
    MUTEX_NB_RECEPT = creer_sem(1);
    MUTEX = creer_sem(1);
    for (int i = 0; i < NR; i++) {
        RECEP[i] = creer_sem(1);
    }

    /* initialisation des semaphores */
    init_un_sem(EMET, NMAX);
    init_un_sem(MUTEX_NB_RECEPT, 1);
    init_un_sem(MUTEX, 1);
    for (int i = 0; i < NR; i++) {
        init_un_sem(RECEP[i], 0);
    }

    /* creation des processus emetteurs */
    for (int i = 0; i < NE; i++) {
        int pid = fork();
        if (pid == 0)
          emetteur();
          exit(0);
    }else if (pid > 0) {
        emet_pid[i] = pid;
     } else {
       // Error occurred
       perror("fork");
       exit(EXIT_FAILURE);
      }
    }

    /* creation des processus recepteurs */
    for (int i = 0; i < NR; i++) {
        int pid = fork();
        if (pid == 0) {
        // Child process
           recepteur(i);
           exit(0);
        } else if (pid > 0) {
        // Parent process
           recep_pid[i] = pid;
        } else {
        // Error occurred
           perror("fork");
           exit(EXIT_FAILURE);
        }
    }

    /* redefinition du traitement de Ctrl-C pour arreter le programme */
    sigemptyset(&action.sa_mask);
    action.sa_flags = 0;
    action.sa_handler = handle_sigint;
    sigaction(SIGINT, &action, 0);

    pause(); /* attente du Ctrl-C */
    return EXIT_SUCCESS;
}