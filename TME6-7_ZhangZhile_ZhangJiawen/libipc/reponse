1.1
Pour assurer la cohérence du compteur partagé nb_recepteurs, on peut introduire un sémaphore mutex (nommé par exemple MUTEX_NB_RECEPT) pour protéger les accès concurrents à cette variable. L'initialisation des sémaphores et variables partagées serait la suivante :

EMET : initialisé à 1, car il y a une case disponible dans le tampon au début.
RECEP[1..NR] : initialisé à 0 pour tous les récepteurs, car il n'y a pas de message à lire au début.
nb_recepteurs : initialisé à 0, car aucun récepteur n'a encore lu de message.
MUTEX_NB_RECEPT : initialisé à 1, pour permettre un accès exclusif à la variable nb_recepteurs.

1.2
On utilise un tableau de sémaphores RECEP[1..NR] plutôt qu'un unique sémaphore RECEP pour éviter que les récepteurs ne lisent le même message plusieurs fois. Avec un tableau, chaque récepteur possède son propre sémaphore et peut être débloqué individuellement lorsqu'un message est disponible. Lorsqu'un émetteur dépose un message, il incrémente la valeur de chaque sémaphore RECEP[i] pour signaler aux récepteurs qu'un message est disponible. Une fois que tous les récepteurs ont lu le message, le dernier récepteur débloque l'émetteur en incrémentant le sémaphore EMET.

1.3. Programmation avec libIPC :

Utilisez les primitives de création et initialisation des sémaphores (SemaphoreCreate, SemaphoreInitialize) pour les sémaphores EMET, MUTEX_NB_RECEPT et RECEP[1..NR].
Dans le code des émetteurs :
Avant d'écrire un message, faites un P(EMET) pour attendre une case libre.
Déposez le message dans la case du tampon.
Faites un V(RECEP[i]) pour chaque récepteur i pour signaler qu'un message est disponible.
Dans le code des récepteurs :
Faites un P(RECEP[i]) pour attendre un message à lire.
Lisez le message du tampon.
Faites un P(MUTEX_NB_RECEPT) pour protéger l'accès à nb_recepteurs.
Incrémentez nb_recepteurs.
