#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <libipc.h>

/************************************************************/

/* definition des parametres */

#define NE          2     /*  Nombre d'emetteurs         */
#define NR          5     /*  Nombre de recepteurs       */

/************************************************************/

/* definition des semaphores */

int EMET;
int MUTEX_NB_RECEPT;
int RECEP[NR];

/************************************************************/

/* definition de la memoire partagee */

typedef struct {
    int message;
    int nb_recepteurs;
} SharedMemory;

SharedMemory *sp;

/************************************************************/

/* variables globales */
int emet_pid[NE], recep_pid[NR];

/************************************************************/

/* traitement de Ctrl-C */

void handle_sigint(int sig) {
    int i;
    for (i = 0; i < NE; i++) kill(emet_pid[i], SIGKILL);
    for (i = 0; i < NR; i++) kill(recep_pid[i], SIGKILL);
    det_sem();
    det_shm((char *)sp);
}

/************************************************************/

/* fonction EMETTEUR */

void emetteur() {
    while (1) {
        P(EMET); // Attendre une case libre

        // Écrire un message (ici, on utilise simplement un nombre aléatoire)
        sp->message = rand() % 100;

        // Signaler aux récepteurs qu'un message est disponible
        for (int i = 0; i < NR; i++) {
            V(RECEP[i]);
        }
    }
}

/************************************************************/

/* fonction RECEPTEUR */

void recepteur(int id) {
    while (1) {
        P(RECEP[id]); // Attendre un message à lire

        // Lire le message
        int message = sp->message;

        // Protéger l'accès au compteur partagé
        P(MUTEX_NB_RECEPT);
        sp->nb_recepteurs++;
        if (sp->nb_recepteurs == NR) {
            // Tous les récepteurs ont lu le message, on libère la case
            sp->nb_recepteurs = 0;
            V(EMET);
        }
        V(MUTEX_NB_RECEPT);
    }
}

/************************************************************/

int main() {
    struct sigaction action;

    setbuf(stdout, NULL);

/* Creation du segment de memoire partagee */

    sp = (SharedMemory *) init_shm(sizeof(SharedMemory));

/* creation des semaphores */

    EMET = creer_sem(1);
    MUTEX_NB_RECEPT = creer_sem(1);
    for (int i = 0; i < NR; i++) {
        RECEP[i] = creer_sem(1);
    }

/* initialisation des semaphores */

    init_un_sem(EMET, 1);
    init_un_sem(MUTEX_NB_RECEPT, 1);
    for (int i = 0; i < NR; i++) {
        init_un_sem(RECEP[i], 0);
    }

/* initialisation de la mémoire partagée */
    sp->nb_recepteurs = 0;

/* creation des processus emetteurs */

    for (int i = 0; i < NE; i++) {
        emet_pid[i] = fork();
        if (emet_pid[i] == 0) {
            emetteur();
            exit(0);
        }
    }
/* creation des processus recepteurs */
    for (int i = 0; i < NR; i++) {
        recep_pid[i] = fork();
        if (recep_pid[i] == 0) {
           recepteur(i);
           exit(0);
        }
    }   
/* redefinition du traitement de Ctrl-C pour arreter le programme */
    sigemptyset(&action.sa_mask);
    action.sa_flags = 0;
    action.sa_handler = handle_sigint;
    sigaction(SIGINT, &action, 0);

    pause();                    /* attente du Ctrl-C  */
    return EXIT_SUCCESS;
}
